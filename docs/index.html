<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeurIPS 2025 Papers - Cluster Visualization</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <!-- sql.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.min.js"></script>

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5FWXEWH5JE"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-5FWXEWH5JE');
    </script>
</head>
<body class="bg-gray-50">
    <div x-data="neuripsApp()" x-init="init()" class="container mx-auto px-4 py-8">
        <!-- Header -->
        <header class="mb-8">
            <h1 class="text-4xl font-bold text-gray-900 mb-2">NeurIPS Papers Explorer</h1>
            <p class="text-gray-600" x-text="`${papers.length} papers across ${clusters.length} clusters`"></p>
        </header>

        <!-- Loading State -->
        <div x-show="loading" class="text-center py-12">
            <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
            <p class="mt-4 text-gray-600 font-semibold">Loading database...</p>
            <p class="mt-2 text-gray-500 text-sm">Downloading compressed database...</p>
            <div class="mt-4 w-64 mx-auto">
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" :style="`width: ${loadingProgress}%`"></div>
                </div>
                <p class="text-center text-xs text-gray-400 mt-1" x-text="`${loadingProgress}%`"></p>
            </div>
        </div>

        <!-- Main Content -->
        <div x-show="!loading" class="space-y-6">
            <!-- Search and Filters -->
            <div class="bg-white rounded-lg shadow p-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Search Bar -->
                    <input
                        type="text"
                        x-model="searchQuery"
                        @input.debounce.300ms="search()"
                        placeholder="Search by title, author, or abstract..."
                        class="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    >
                    <!-- Year Filter -->
                    <select
                        x-model="selectedYear"
                        @change="filterPapers()"
                        class="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    >
                        <option value="">All Years</option>
                        <template x-for="year in availableYears" :key="year">
                            <option :value="year" x-text="year"></option>
                        </template>
                    </select>
                </div>
                <p class="text-sm text-gray-500 mt-2" x-show="searchQuery || selectedYear" x-text="`Found ${filteredPapers.length} papers`"></p>
            </div>

            <!-- Two Column Layout -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Left Column: Clusters & Papers List -->
                <div class="lg:col-span-1 space-y-4">
                    <!-- Cluster Selector -->
                    <div class="bg-white rounded-lg shadow p-4">
                        <h2 class="text-xl font-semibold mb-4">Clusters</h2>
                        <div class="space-y-2">
                            <button
                                @click="selectedCluster = null; filterPapers()"
                                :class="selectedCluster === null ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'"
                                class="w-full text-left px-3 py-2 rounded-lg hover:bg-blue-500 hover:text-white transition"
                            >
                                All Papers
                            </button>
                            <template x-for="cluster in clusters" :key="cluster.id">
                                <button
                                    @click="selectedCluster = cluster.id; filterPapers()"
                                    :class="selectedCluster === cluster.id ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'"
                                    class="w-full text-left px-3 py-2 rounded-lg hover:bg-blue-500 hover:text-white transition"
                                >
                                    <div class="font-medium" x-html="processText(cluster.name)"></div>
                                    <div class="text-xs opacity-75">
                                        <span x-text="`${cluster.count} papers`"></span>
                                        <span x-show="cluster.year && !selectedYear" x-text="` • ${cluster.year}`"></span>
                                    </div>
                                </button>
                            </template>
                        </div>
                    </div>

                    <!-- Papers List -->
                    <div class="bg-white rounded-lg shadow p-4">
                        <h2 class="text-xl font-semibold mb-4">Papers</h2>
                        <div class="space-y-2 max-h-96 overflow-y-auto mb-4">
                            <template x-for="paper in paginatedPapers" :key="paper.id">
                                <button
                                    @click="selectedPaper = paper"
                                    :class="selectedPaper?.id === paper.id ? 'bg-blue-50 border-blue-500' : 'border-gray-200'"
                                    class="w-full text-left px-3 py-2 border rounded-lg hover:border-blue-500 transition"
                                >
                                    <div class="text-sm font-medium text-gray-900 line-clamp-2" x-html="processText(paper.name)"></div>
                                </button>
                            </template>
                        </div>

                        <!-- Pagination Controls -->
                        <div x-show="totalPages > 1" class="flex items-center justify-between border-t pt-4">
                            <p class="text-sm text-gray-500">
                                Showing <span x-text="(currentPage - 1) * itemsPerPage + 1"></span> to
                                <span x-text="Math.min(currentPage * itemsPerPage, filteredPapers.length)"></span> of
                                <span x-text="filteredPapers.length"></span> papers
                            </p>
                            <div class="flex gap-2">
                                <button
                                    @click="prevPage()"
                                    :disabled="currentPage === 1"
                                    :class="currentPage === 1 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-100'"
                                    class="px-3 py-1 border rounded text-sm"
                                >
                                    Previous
                                </button>
                                <span class="px-3 py-1 text-sm">
                                    <span x-text="currentPage"></span>/<span x-text="totalPages"></span>
                                </span>
                                <button
                                    @click="nextPage()"
                                    :disabled="currentPage === totalPages"
                                    :class="currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-100'"
                                    class="px-3 py-1 border rounded text-sm"
                                >
                                    Next
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Visualization & Details -->
                <div class="lg:col-span-2 space-y-4">
                    <!-- UMAP Visualization -->
                    <div class="bg-white rounded-lg shadow p-4">
                        <h2 class="text-xl font-semibold mb-4">UMAP Visualization</h2>
                        <div id="umap-plot" style="width: 100%; height: 600px;"></div>
                    </div>

                    <!-- Paper Details -->
                    <div x-show="selectedPaper" class="bg-white rounded-lg shadow p-6">
                        <h2 class="text-2xl font-bold text-gray-900 mb-2" x-html="processText(selectedPaper?.name)"></h2>

                        <div class="mb-4 flex gap-2">
                            <span class="inline-block bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded" x-text="selectedPaper?.type"></span>
                            <span x-show="selectedPaper?.year" class="inline-block bg-gray-100 text-gray-800 text-xs px-2 py-1 rounded" x-text="selectedPaper?.year"></span>
                        </div>

                        <div class="mb-4" x-show="selectedPaper?.speakers_authors">
                            <h3 class="font-semibold text-gray-700 mb-1">Authors</h3>
                            <p class="text-gray-600" x-text="selectedPaper?.speakers_authors"></p>
                        </div>

                        <div class="mb-4" x-show="selectedPaper?.abstract">
                            <h3 class="font-semibold text-gray-700 mb-1">Abstract</h3>
                            <div class="text-gray-600 text-sm" x-html="processText(selectedPaper?.abstract) + '...'"></div>
                        </div>

                        <div x-show="selectedPaper?.virtualsite_url">
                            <a :href="selectedPaper?.virtualsite_url"
                               target="_blank"
                               class="inline-block bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition">
                                View on NeurIPS →
                            </a>
                        </div>

                        <div class="mt-4" x-show="selectedPaper?.clusters">
                            <h3 class="font-semibold text-gray-700 mb-2">Cluster</h3>
                            <div class="flex flex-wrap gap-2">
                                <template x-for="c in selectedPaper?.clusters" :key="c.cluster_id">
                                    <button
                                        @click="selectedCluster = c.cluster_id; filterPapers()"
                                        class="bg-gray-100 text-gray-700 text-sm px-3 py-1 rounded hover:bg-gray-200"
                                    >
                                        <span x-html="processText(c.cluster_name)"></span>
                                    </button>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function neuripsApp() {
            return {
                db: null,
                loading: true,
                loadingProgress: 0,
                isLoadingDatabase: false,
                papers: [],
                clusters: [],
                filteredPapers: [],
                selectedCluster: null,
                selectedPaper: null,
                searchQuery: '',
                selectedYear: '',
                availableYears: [],
                previousYear: '',
                currentPage: 1,
                itemsPerPage: 50,

                // Process text with LaTeX and markdown
                processText(text) {
                    if (!text) return '';

                    // First, convert markdown to HTML
                    let processed = marked.parse(text, { breaks: true });

                    // Then render LaTeX formulas
                    // Handle inline formulas: $...$
                    processed = processed.replace(/\$([^$]+)\$/g, (match, formula) => {
                        try {
                            return katex.renderToString(formula, { throwOnError: false });
                        } catch (e) {
                            return match;
                        }
                    });

                    // Handle display formulas: $$...$$
                    processed = processed.replace(/\$\$([^$]+)\$\$/g, (match, formula) => {
                        try {
                            return katex.renderToString(formula, { displayMode: true, throwOnError: false });
                        } catch (e) {
                            return match;
                        }
                    });

                    // Handle \(...\) inline formulas
                    processed = processed.replace(/\\\((.+?)\\\)/g, (match, formula) => {
                        try {
                            return katex.renderToString(formula, { throwOnError: false });
                        } catch (e) {
                            return match;
                        }
                    });

                    // Handle \[...\] display formulas
                    processed = processed.replace(/\\\[(.+?)\\\]/g, (match, formula) => {
                        try {
                            return katex.renderToString(formula, { displayMode: true, throwOnError: false });
                        } catch (e) {
                            return match;
                        }
                    });

                    return processed;
                },

                async init() {
                    await this.loadDatabase();
                    this.loadYears();
                    // Set the most recent year as default
                    if (this.availableYears.length > 0) {
                        this.selectedYear = this.availableYears[0];
                    }
                    this.loadClusters();
                    this.loadPapers();
                    this.filterPapers();
                    this.renderUMAP();
                    this.loading = false;
                },

                async loadDatabase() {
                    // Prevent multiple simultaneous loads
                    if (this.isLoadingDatabase) {
                        console.log('Database load already in progress, skipping...');
                        return;
                    }

                    this.isLoadingDatabase = true;

                    try {
                        // Initialize sql.js
                        const SQL = await initSqlJs({
                            locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
                        });

                        // Load the compressed database file from S3 with progress tracking
                        const response = await fetch('https://lgemc-static.s3.amazonaws.com/neurips.db.gz', {
                            cache: 'default'
                        });

                    if (!response.ok) {
                        throw new Error(`Failed to fetch database: ${response.status}`);
                    }

                    const contentLength = response.headers.get('content-length');
                    const total = parseInt(contentLength, 10);

                    const reader = response.body.getReader();
                    const chunks = [];
                    let receivedLength = 0;

                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            chunks.push(value);
                            receivedLength += value.length;

                            // Update progress - cap at 100%
                            if (total > 0) {
                                this.loadingProgress = Math.min(100, Math.round((receivedLength / total) * 100));
                            }
                        }
                    } finally {
                        reader.releaseLock();
                    }

                    // Download complete - ensure progress shows 100%
                    this.loadingProgress = 100;

                    // Combine chunks into single array
                    const compressedBuffer = new Uint8Array(receivedLength);
                    let position = 0;
                    for (const chunk of chunks) {
                        compressedBuffer.set(chunk, position);
                        position += chunk.length;
                    }

                        // Decompress gzip data using browser's DecompressionStream
                        const decompressedStream = new Response(
                            new Blob([compressedBuffer]).stream().pipeThrough(new DecompressionStream('gzip'))
                        );
                        const decompressedBuffer = await decompressedStream.arrayBuffer();

                        this.db = new SQL.Database(new Uint8Array(decompressedBuffer));
                        console.log('Database loaded successfully');
                    } finally {
                        this.isLoadingDatabase = false;
                    }
                },

                loadYears() {
                    const result = this.db.exec(`
                        SELECT DISTINCT year
                        FROM papers
                        WHERE year IS NOT NULL
                        ORDER BY year DESC
                    `);

                    if (result[0]) {
                        this.availableYears = result[0].values.map(row => row[0]);
                    }
                },

                loadClusters() {
                    const yearFilter = this.selectedYear ? `WHERE c.year = ${this.selectedYear}` : '';
                    const result = this.db.exec(`
                        SELECT
                            c.id,
                            c.name,
                            c.description,
                            c.year,
                            COUNT(CASE WHEN ca.score > 0.1 THEN ca.paper_id END) as count
                        FROM clusters c
                        LEFT JOIN cluster_associations ca ON c.id = ca.cluster_id
                        ${yearFilter}
                        GROUP BY c.id
                        ORDER BY c.year DESC, c.id
                    `);

                    if (result[0]) {
                        this.clusters = result[0].values.map(row => ({
                            id: row[0],
                            name: row[1],
                            description: row[2],
                            year: row[3],
                            count: row[4]
                        }));
                    }
                },

                loadPapers() {
                    const result = this.db.exec(`
                        SELECT
                            p.id,
                            p.type,
                            p.name,
                            p.virtualsite_url,
                            p.speakers_authors,
                            p.abstract,
                            p.year,
                            p.umap_x,
                            p.umap_y
                        FROM papers p
                        WHERE p.umap_x IS NOT NULL
                        ORDER BY p.id
                    `);

                    if (result[0]) {
                        this.papers = result[0].values.map(row => ({
                            id: row[0],
                            type: row[1],
                            name: row[2],
                            virtualsite_url: row[3],
                            speakers_authors: row[4],
                            abstract: row[5],
                            year: row[6],
                            umap_x: row[7],
                            umap_y: row[8],
                            clusters: this.getPaperClusters(row[0])
                        }));
                    }
                },

                getPaperClusters(paperId) {
                    const result = this.db.exec(`
                        SELECT
                            ca.cluster_id,
                            c.name,
                            ca.score
                        FROM cluster_associations ca
                        JOIN clusters c ON ca.cluster_id = c.id
                        WHERE ca.paper_id = ${paperId}
                        ORDER BY ca.score DESC
                    `);

                    if (result[0]) {
                        return result[0].values.map(row => ({
                            cluster_id: row[0],
                            cluster_name: row[1],
                            score: row[2]
                        }));
                    }
                    return [];
                },

                get paginatedPapers() {
                    const start = (this.currentPage - 1) * this.itemsPerPage;
                    const end = start + this.itemsPerPage;
                    return this.filteredPapers.slice(start, end);
                },

                get totalPages() {
                    return Math.ceil(this.filteredPapers.length / this.itemsPerPage);
                },

                nextPage() {
                    if (this.currentPage < this.totalPages) {
                        this.currentPage++;
                    }
                },

                prevPage() {
                    if (this.currentPage > 1) {
                        this.currentPage--;
                    }
                },

                goToPage(page) {
                    this.currentPage = Math.max(1, Math.min(page, this.totalPages));
                },

                filterPapers() {
                    this.currentPage = 1; // Reset to first page when filtering

                    // Reset to "All Papers" only when year changes
                    if (this.selectedYear !== this.previousYear && this.selectedCluster !== null) {
                        this.selectedCluster = null;
                    }
                    this.previousYear = this.selectedYear;

                    // Reload clusters when year filter changes
                    this.loadClusters();

                    if (this.selectedCluster === null && !this.searchQuery && !this.selectedYear) {
                        this.filteredPapers = this.papers;
                        this.renderUMAP();
                        return;
                    }

                    if (this.selectedCluster !== null) {
                        // Get papers in selected cluster, sorted by score
                        const yearFilter = this.selectedYear ? `AND p.year = ${this.selectedYear}` : '';
                        const searchFilter = this.searchQuery ? `AND (p.name LIKE '%${this.searchQuery}%' OR p.abstract LIKE '%${this.searchQuery}%' OR p.speakers_authors LIKE '%${this.searchQuery}%')` : '';

                        const result = this.db.exec(`
                            SELECT
                                p.id,
                                p.type,
                                p.name,
                                p.virtualsite_url,
                                p.speakers_authors,
                                p.abstract,
                                p.year,
                                p.umap_x,
                                p.umap_y,
                                ca.score
                            FROM papers p
                            JOIN cluster_associations ca ON p.id = ca.paper_id
                            WHERE ca.cluster_id = ${this.selectedCluster}
                            ${yearFilter}
                            ${searchFilter}
                            ORDER BY ca.score DESC
                        `);

                        if (result[0]) {
                            this.filteredPapers = result[0].values.map(row => ({
                                id: row[0],
                                type: row[1],
                                name: row[2],
                                virtualsite_url: row[3],
                                speakers_authors: row[4],
                                abstract: row[5],
                                year: row[6],
                                umap_x: row[7],
                                umap_y: row[8],
                                score: row[9],
                                clusters: this.getPaperClusters(row[0])
                            }));
                        } else {
                            this.filteredPapers = [];
                        }
                    } else {
                        this.search();
                    }

                    this.renderUMAP();
                },

                search() {
                    if (!this.searchQuery && !this.selectedYear) {
                        this.filterPapers();
                        return;
                    }

                    this.currentPage = 1; // Reset to first page when searching
                    const query = this.searchQuery.toLowerCase();
                    this.filteredPapers = this.papers.filter(paper => {
                        const matchesSearch = !this.searchQuery ||
                            paper.name.toLowerCase().includes(query) ||
                            (paper.abstract && paper.abstract.toLowerCase().includes(query)) ||
                            (paper.speakers_authors && paper.speakers_authors.toLowerCase().includes(query));
                        const matchesYear = !this.selectedYear || paper.year == this.selectedYear;
                        return matchesSearch && matchesYear;
                    });

                    this.renderUMAP();
                },

                renderUMAP() {
                    const displayPapers = this.filteredPapers.length > 0 ? this.filteredPapers : this.papers;

                    // Group papers by cluster for coloring
                    const traces = [];

                    if (this.selectedCluster !== null) {
                        // Single cluster view
                        const trace = {
                            x: displayPapers.map(p => p.umap_x),
                            y: displayPapers.map(p => p.umap_y),
                            mode: 'markers',
                            type: 'scatter',
                            name: this.clusters.find(c => c.id === this.selectedCluster)?.name || 'Cluster',
                            text: displayPapers.map(p => p.name),
                            customdata: displayPapers.map(p => p.id),
                            marker: {
                                size: 5,
                                color: this.selectedCluster,
                                colorscale: 'Viridis',
                                opacity: 0.7
                            },
                            hovertemplate: '<b>%{text}</b><extra></extra>'
                        };
                        traces.push(trace);
                    } else {
                        // All clusters view - color by primary cluster
                        const clusterGroups = {};

                        displayPapers.forEach(paper => {
                            const primaryCluster = paper.clusters[0]?.cluster_id || 0;
                            if (!clusterGroups[primaryCluster]) {
                                clusterGroups[primaryCluster] = [];
                            }
                            clusterGroups[primaryCluster].push(paper);
                        });

                        Object.entries(clusterGroups).forEach(([clusterId, papers]) => {
                            const cluster = this.clusters.find(c => c.id === parseInt(clusterId));
                            const trace = {
                                x: papers.map(p => p.umap_x),
                                y: papers.map(p => p.umap_y),
                                mode: 'markers',
                                type: 'scatter',
                                name: cluster?.name || 'Unknown',
                                text: papers.map(p => p.name),
                                customdata: papers.map(p => p.id),
                                marker: {
                                    size: 5,
                                    opacity: 0.6
                                },
                                hovertemplate: '<b>%{text}</b><extra></extra>'
                            };
                            traces.push(trace);
                        });
                    }

                    const layout = {
                        title: this.selectedCluster
                            ? this.clusters.find(c => c.id === this.selectedCluster)?.name
                            : 'All Papers',
                        xaxis: { title: 'UMAP 1' },
                        yaxis: { title: 'UMAP 2' },
                        hovermode: 'closest',
                        showlegend: true,
                        margin: { t: 40, r: 20, b: 40, l: 40 }
                    };

                    const config = {
                        responsive: true,
                        displayModeBar: true,
                        displaylogo: false
                    };

                    Plotly.newPlot('umap-plot', traces, layout, config);

                    // Add click handler to select paper
                    document.getElementById('umap-plot').on('plotly_click', (data) => {
                        const point = data.points[0];
                        const paperId = point.customdata;
                        if (paperId) {
                            this.selectedPaper = this.papers.find(p => p.id === paperId);
                        }
                    });
                }
            }
        }
    </script>
</body>
</html>
